# Отчёт по лабораторной работе  
## 3D Визуализация и матричные преобразования  

---

## Цели работы  

Основные цели лабораторной работы:  

- Изучить теоретические основы 3D геометрии и матричных преобразований  
- Реализовать генерацию 3D модели буквы "С" с параметрической геометрией  
- Разработать систему матричных преобразований для вращения, масштабирования и переноса  
- Создать интерактивное веб-приложение с несколькими проекциями 3D модели  
- Реализовать интуитивное управление с помощью мыши и ползунков  

---

## Теоретическое исследование 3D преобразований  

### Матричные преобразования в компьютерной графике  

**Матрица 4×4** используется для однородных координат в 3D пространстве. В однородных координатах точка представляется как `(x, y, z, 1)`, а вектор как `(x, y, z, 0)`. Это позволяет объединить линейные преобразования (поворот, масштабирование) и аффинные преобразования (перенос) в одной матрице.

**Структура матрицы 4×4:**
```
[ m00  m01  m02  m03 ]   - поворот/масштабирование по X + перенос по X
[ m10  m11  m12  m13 ]   - поворот/масштабирование по Y + перенос по Y  
[ m20  m21  m22  m23 ]   - поворот/масштабирование по Z + перенос по Z
[  0    0    0    1  ]   - однородная координата (всегда 0,0,0,1 для преобразований)
```

### Математические основы преобразований

#### 1. Матрица масштабирования:
```
[ Sx   0    0    0 ]
[ 0    Sy   0    0 ]
[ 0    0    Sz   0 ]
[ 0    0    0    1 ]
```
где:
- `Sx`, `Sy`, `Sz` - коэффициенты масштабирования по осям X, Y, Z

#### 2. Матрица вращения вокруг оси X:
```
[ 1    0       0       0 ]
[ 0    cosθ   -sinθ    0 ]
[ 0    sinθ    cosθ    0 ]
[ 0    0       0       1 ]
```

#### 3. Матрица вращения вокруг оси Y:
```
[ cosθ   0    sinθ    0 ]
[ 0      1    0       0 ]
[-sinθ   0    cosθ    0 ]
[ 0      0    0       1 ]
```

#### 4. Матрица переноса (трансляции):
```
[ 1    0    0    Tx ]
[ 0    1    0    Ty ]  
[ 0    0    1    Tz ]
[ 0    0    0    1  ]
```
где:
- `Tx`, `Ty`, `Tz` - величины смещения по осям X, Y, Z

---

## Построение итоговой матрицы преобразований

### Порядок применения преобразований

В компьютерной графике важен порядок умножения матриц, так как матричное умножение некоммутативно. В данной работе используется следующий порядок:

**M = T × R × S**

где:
- S - масштабирование (применяется первым к вершинам)
- R - вращение (вторым)
- T - перенос (последним)

### Реализация в коде

```javascript
// 1. Создание отдельных матриц
const mS = Matrix4.scale(state.scale);           // Матрица масштабирования
const mRx = Matrix4.rotX(state.rotX);           // Матрица вращения вокруг X
const mRy = Matrix4.rotY(state.rotY);           // Матрица вращения вокруг Y
const mT = Matrix4.translate(state.tx, -state.ty, state.tz);  // Матрица переноса

// 2. Объединение матриц вращения
const mRot = new Matrix4().multiply(mRy).multiply(mRx);

// 3. Построение итоговой матрицы (порядок: T × R × S)
const mat = new Matrix4();
mat.multiply(mT).multiply(mRot).multiply(mS);
```

### Конкретные значения в матрицах

#### Пример 1: Матрица масштабирования при `scale = 1.5`
```
[ 1.5  0    0    0 ]
[ 0    1.5  0    0 ]
[ 0    0    1.5  0 ]
[ 0    0    0    1 ]
```

#### Пример 2: Матрица вращения вокруг Y при `rotY = -30°`
```
[ 0.87   0   -0.50  0 ]
[ 0      1    0     0 ]
[ 0.50   0    0.87  0 ]
[ 0      0    0     1 ]
```

#### Пример 3: Матрица переноса при `tx = 100, ty = 50, tz = -200`
```
[ 1   0   0   100 ]
[ 0   1   0   -50 ]  // Обратите внимание: ty = -50 (инверсия Y)
[ 0   0   1  -200 ]
[ 0   0   0    1  ]
```

### Итоговая матрица преобразований

При начальных значениях:
- `scale = 1.5`
- `rotX = 15°`
- `rotY = -30°`
- `translation = (0, 0, 0)`

Итоговая матрица будет иметь вид:
```
[  1.30   0.00  -0.75   0.00 ]  // Строка 0: преобразование X
[  0.43   0.87   0.25   0.00 ]  // Строка 1: преобразование Y
[  0.65  -0.50   1.12   0.00 ]  // Строка 2: преобразование Z  
[  0.00   0.00   0.00   1.00 ]  // Строка 3: однородная координата
```

---

## Назначение и применение матрицы преобразований

### Для чего нужна матрица преобразований

1. **Объединение преобразований** - позволяет выполнить масштабирование, вращение и перенос за одну операцию
2. **Эффективность вычислений** - вместо последовательного применения трёх операций к каждой вершине, применяется одна матрица
3. **Инверсия преобразований** - обратная матрица позволяет выполнить обратное преобразование
4. **Композиция преобразований** - можно комбинировать несколько матриц для создания сложных анимаций

### Применение матрицы к вершинам

Каждая вершина модели преобразуется с помощью матрицы:

```javascript
transform(v) {
    return {
        // x' = m00*x + m01*y + m02*z + m03
        x: this.d[0]*v.x + this.d[1]*v.y + this.d[2]*v.z + this.d[3],
        
        // y' = m10*x + m11*y + m12*z + m13  
        y: this.d[4]*v.x + this.d[5]*v.y + this.d[6]*v.z + this.d[7],
        
        // z' = m20*x + m21*y + m22*z + m23
        z: this.d[8]*v.x + this.d[9]*v.y + this.d[10]*v.z + this.d[11]
    };
}
```

### Визуализация в интерфейсе

Итоговая матрица отображается в интерфейсе для наглядности:
```
[  1.30,   0.00,  -0.75,   0.00]
[  0.43,   0.87,   0.25,   0.00]
[  0.65,  -0.50,   1.12,   0.00]
[  0.00,   0.00,   0.00,   1.00]
```

Где:
- **Первые 3 столбца (0-2)** - отвечают за поворот и масштабирование
- **Последний столбец (3)** - отвечает за перенос
- **Последняя строка** - всегда `[0, 0, 0, 1]` для преобразований координат

---

## Генерация 3D модели буквы "С"  

### Параметрическое описание геометрии  

Модель строится как трубчатая структура с внешним и внутренним радиусами:  

```javascript
const segments = 40;      // Количество сечений для плавности
const R_outer = 120;     // Внешний радиус
const R_inner = 80;      // Внутренний радиус  
const depth = 40;        // Глубина (толщина) буквы
```

### Алгоритм генерации вершин  

1. Разбиваем дугу от 40° до 320° на `segments` частей  
2. Для каждого угла создаём 4 точки:  
   - Внешняя точка передней грани  
   - Внутренняя точка передней грани  
   - Внешняя точка задней грани  
   - Внутренняя точка задней грани  
3. Координаты вычисляются по формулам:  
   ```
   x = R * cos(θ)
   y = -R * sin(θ)  // Отрицание для правильной ориентации
   z = ±depth/2     // Для передней/задней граней
   ```

### Структура данных модели  

```javascript
model = {
    vertices: [  // Массив объектов {x, y, z}
        {x: c*R_outer, y: -s*R_outer, z: depth/2},  // Точка 0
        {x: c*R_inner, y: -s*R_inner, z: depth/2},  // Точка 1
        // ... всего segments * 4 точек
    ],
    edges: [     // Массив пар индексов вершин
        [0, 1],  // Ребро между точками 0 и 1
        [2, 3],  // Ребро между точками 2 и 3
        // ... рёбра для сечений и соединений
    ]
}
```

---

## Система отображения и проекции  

### Три типа проекций  

1. **Перспективная проекция (главный вид)**  
   Использует простое перспективное преобразование:  
   ```
   projection_factor = f / (f - z)
   x_screen = center_x + x * projection_factor
   y_screen = center_y - y * projection_factor  // Ось Y инвертирована
   ```
   где f = 1000 (фокусное расстояние)

2. **Ортографические проекции (три вида)**  
   - **Oxy (Фронтальная)**: отбрасывается координата Z  
     ```
     x_screen = center_x + x * scale
     y_screen = center_y - y * scale
     ```
   - **Oxz (Вид сверху)**: отбрасывается координата Y  
     ```
     x_screen = center_x + x * scale  
     y_screen = center_y - z * scale  // Z становится вертикальной осью
     ```
   - **Oyz (Вид сбоку)**: отбрасывается координата X  
     ```
     x_screen = center_x + z * scale  // Z становится горизонтальной осью
     y_screen = center_y - y * scale
     ```

### Алгоритм рендеринга  

```javascript
function render() {
    // 1. Формирование итоговой матрицы преобразований
    const mat = new Matrix4()
        .multiply(mT)    // Перенос
        .multiply(mRot)  // Вращение (Ry × Rx)
        .multiply(mS);   // Масштабирование
    
    // 2. Трансформация всех вершин
    const tVerts = model.vertices.map(v => mat.transform(v));
    
    // 3. Отрисовка рёбер на всех четырёх канвасах
    model.edges.forEach(e => {
        const v1 = tVerts[e[0]];
        const v2 = tVerts[e[1]];
        
        // Для каждого канваса: вычисление проекции и рисование линии
    });
}
```

---

## Система управления и интерфейс  

### Интерактивное управление мышью  

**Вращение модели:**  
- Зажатие ЛКМ + движение мыши: вращение вокруг осей X и Y  
- Чувствительность: 0.5 градуса на пиксель  

**Масштабирование:**  
- Колесо мыши: увеличение/уменьшение масштаба  
- Диапазон масштаба: от 0.1 до 5.0  

### Элементы управления интерфейса  

**Блок управления поворотом:**  
- Ползунки для осей X и Y (-180° до 180°)  
- Отображение текущих значений  

**Блок управления масштабом:**  
- Ползунок масштаба (0.1 до 5.0)  
- Шаг изменения: 0.1  

**Блок управления переносом:**  
- Отдельные ползунки для осей X, Y, Z  
- Диапазоны: X: ±300, Y: ±200, Z: ±500  

**Дополнительные элементы:**  
- Кнопка сброса камеры  
- Панель вывода итоговой матрицы преобразований  
- Мини-подсказки по управлению  

---

## Особенности реализации  

### Обработка вращения  

Для создания "орбитальной" камеры:  
1. Вращение вокруг Y меняется при горизонтальном движении мыши  
2. Вращение вокруг X меняется при вертикальном движении  
3. Сочетание даёт полный контроль над ориентацией модели  

### Система координат и проекции  

- Мировая система координат: правая, Z направлена от зрителя  
- Экранная система: левая, Y направлена вниз  
- При преобразованиях учитывается инверсия оси Y: `y_screen = center_y - y_world`  

---

## Тестирование функциональности  

### Тестовые сценарии  

1. **Проверка матричных преобразований**  
   - Умножение единичной матрицы: должна оставаться неизменной  
   - Обратные преобразования: M × M⁻¹ = I (единичная матрица)  
   - Порядок умножения: проверка некоммутативности  

2. **Проверка преобразований вершин**  
   - Масштабирование в 2 раза: все координаты должны удвоиться  
   - Вращение на 90° вокруг Y: x → -z, z → x  
   - Перенос на (100, 50, -200): все координаты должны сместиться  

3. **Визуальная проверка проекций**  
   - Фронтальная проекция: должна отображать контур буквы "С"  
   - Вид сверху: должна отображать толщину буквы  
   - Вид сбоку: должна отображать профиль буквы  

### Примеры тестовых значений  

**Тест 1: Только масштабирование**  
```
Исходная вершина: (100, 50, 30)
Матрица: scale(2)
Результат: (200, 100, 60) ✓
```

**Тест 2: Только вращение**  
```
Исходная вершина: (100, 0, 0)
Матрица: rotateY(90°)
Результат: (0, 0, -100) ✓
```

**Тест 3: Комбинированное преобразование**  
```
Исходная вершина: (10, 20, 30)
Матрица: translate(5,10,15) × rotateY(45°) × scale(2)
Проверка: ручной расчет и сравнение ✓
```

---

## Итоговый вывод  

В ходе работы было разработано интерактивное веб-приложение для 3D визуализации с матричными преобразованиями. Реализованы все ключевые аспекты компьютерной графики:  

**Основные достижения:**  
1. **Генерация 3D модели** - создана параметрическая модель буквы "С" с трубчатой структурой  
2. **Система матричных преобразований** - реализован полный класс Matrix4 с поддержкой всех базовых преобразований  
3. **Многопроекционный интерфейс** - одновременное отображение перспективной и трёх ортографических проекций  
4. **Интуитивное управление** - интеграция мышиного управления с синхронизацией через ползунки  
5. **Наглядная визуализация** - отображение итоговой матрицы преобразований с объяснением её структуры  

**Ключевые аспекты матричных преобразований:**  
- Понимание структуры матрицы 4×4 и её элементов  
- Правильный порядок умножения матриц: T × R × S  
- Применение матрицы к вершинам через умножение матрицы на вектор  
- Отображение матрицы в понятном для пользователя формате  

**Практическая ценность:**  
- Получены навыки работы с 3D геометрией и матричной алгеброй  
- Освоены принципы построения многопроекционных интерфейсов  
- Разработано рабочее приложение для изучения 3D преобразований  
- Создан инструмент для визуализации матричных операций в реальном времени
